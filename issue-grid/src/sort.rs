
use std::{
    collections::HashSet,
    fmt::{Arguments, Debug},
    slice,
};

use regex::Regex;

// == instructions ==

/// Definition for binning and sorting issues.
pub type OrganizeDefinition = OrganizeScope;

/// Recursive definition for binning and sorting issues.
#[derive(Debug, Clone)]
pub struct OrganizeScope {
    targets: Vec<(FilterSort, SortTarget)>,
}

/// Part of recursive definition for binning and sorting issues.
#[derive(Debug, Clone)]
pub enum SortTarget {
    Bin,
    Recurse(Box<OrganizeScope>),
}

/// Definition for filtering and sorting issues by matching tags.
#[derive(Debug, Clone)]
pub struct FilterSort {
    pub filter: Regex,
    /// Optional explicit ordering.
    pub sorter: Option<PatternSequence>,
}

/// A sequence of elements which can order elements by its first
/// matching pattern.
#[derive(Debug, Clone)]
pub struct PatternSequence {
    pub patterns: Vec<Regex>,
}

/// A stack of `PatternSequence` which can order elements by the
/// first stack to distinct it between its neighbors.
#[derive(Debug, Clone)]
pub struct PatternSequenceStack {
    pub stack: Vec<PatternSequence>,
}

/// The comparable key generated by matching on a
/// `PatternSequenceStack`.
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct FirstMatchStack(pub Vec<Option<usize>>);

// == operations ==

pub trait RegexTest {
    fn is_match(&self, regex: &Regex) -> bool;
}

// == algorithm

impl PatternSequence {
    pub fn first_match<T: RegexTest + Debug>(&self, &elem: T) -> Option<usize> {
        let option = self.patterns.iter()
            .enumerate()
            .find(|&(_, regex)| elem.is_match(regex))
            .map(|(i, _)| i);
        if option.is_none() {
            eprintln!(r##"
[ERROR] element does not match any pattern!
        element: {:?}
        patterns: {:?}
            "##, elem, self.patterns)
        }
        option
    }
}

impl PatternSequenceStack {
    pub fn first_match_stack<T: RegexTest>(&self, &elem: T) -> FirstMatchStack {
        let vec = self.stack.iter()
            .map(|pat_seq| pat_seq.first_match(elem))
            .collect();
        FirstMatchStack(vec)
    }

    pub fn new() -> Self {
        let stack = Vec::with_capacity(0);
        PatternSequenceStack { stack }
    }
    /*

    /// Clone/append
    pub fn then(&self, seq: PatternSequence) -> Self {
        let mut stack = Vec::with_capacity(self.stack.len() + 1);
        stack.extend(self.stack.iter().cloned());
        stack.push(seq);
        PatternSequenceStack { stack }
    }

    /// Clone/concatenate
    pub fn join(&self, other: &Self) -> Self {
        let mut stack = Vec::with_capacity(
            self.stack.len() + other.stack.len()
        );
        stack.extend(self.stack.iter().cloned());
        stack.extend(other.stack.iter().clonde());
        PatternSequenceStack { stack }
    }
    */
}

impl OrganizeScope {
    /// Bin and sort the elements.
    pub fn organize<T>(&self, elems: &[T]) -> Vec<Vec<T>>
    where
        T: RegexTest + Clone,
    {
        // DFS stack frame
        struct Frame<'a> {
            targets: slice::Iter<'a, (FilterSort, SortTarget)>,
            sort_stack: PatternSequenceStack,
        }

        let mut frames: Vec<Frame> = Vec::new();
        let mut bins: Vec<Vec<(T, FirstMatchStack)>> = Vec::new();

        frames.push(Frame {
            targets: self.targets.iter(),
            sort_stack: PatternSequenceStack::new(),
        });

        // bin with DFS
        // (look for the continue statements)
        while let Some(mut top_frame) = frames.pop() {
            let (
                &FilterSort {
                    filter: ref curr_filter,
                    sorter: ref curr_sorter,
                },
                curr_target
            ) = match top_frame.targets.next() {
                Some(tuple) => tuple,
                None => continue, // fall back
            };

            let mut curr_sort_stack = top_frame.sort_stack.clone();
            if let Some(pat_seq) = curr_sorter.clone() {
                curr_sort_stack.stack.push(pat_seq);
            }

            match curr_target {
                &SortTarget::Bin => {

                    let bin: Vec<(T, FirstMatchStack)> = elems.iter()
                        .filter(|&elem| elem.is_match(curr_filter))
                        .cloned()
                        .map(|elem| {
                            let ord =
                                curr_sort_stack.first_match_stack(&elem);
                            (elem, ord)
                        })
                        .collect();
                    bins.push(bin);

                    // iterate
                    frames.push(top_frame);
                    continue;
                }
                &SortTarget::Recurse(ref sub_scope) => {

                    // recurse
                    frames.push(top_frame);
                    frames.push(Frame {
                        targets: sub_scope.targets.iter(),
                        sort_stack: curr_sort_stack,
                    });
                    continue;
                }
            };
        }

        // sort and finalize
        let bins: Vec<Vec<T>> = bins.into_iter()
            .map(|mut bin| {
                bin.sort_by(|
                    &(_, ref s1),
                    &(_, ref s2)
                | s1.cmp(s2) );
                bin.into_iter()
                    .map(|(elem, _)| elem)
                    .collect()
            })
            .collect();

        bins
    }
}
